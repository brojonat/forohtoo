// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transactions.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countTransactionsByWallet = `-- name: CountTransactionsByWallet :one
SELECT COUNT(*) FROM transactions
WHERE wallet_address = $1
`

func (q *Queries) CountTransactionsByWallet(ctx context.Context, walletAddress string) (int64, error) {
	row := q.db.QueryRow(ctx, countTransactionsByWallet, walletAddress)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
    signature,
    wallet_address,
    slot,
    block_time,
    amount,
    token_mint,
    memo,
    confirmation_status,
    from_address
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING signature, wallet_address, slot, block_time, amount, token_mint, memo, confirmation_status, created_at, from_address
`

type CreateTransactionParams struct {
	Signature          string             `json:"signature"`
	WalletAddress      string             `json:"wallet_address"`
	Slot               int64              `json:"slot"`
	BlockTime          pgtype.Timestamptz `json:"block_time"`
	Amount             int64              `json:"amount"`
	TokenMint          pgtype.Text        `json:"token_mint"`
	Memo               pgtype.Text        `json:"memo"`
	ConfirmationStatus string             `json:"confirmation_status"`
	FromAddress        pgtype.Text        `json:"from_address"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.Signature,
		arg.WalletAddress,
		arg.Slot,
		arg.BlockTime,
		arg.Amount,
		arg.TokenMint,
		arg.Memo,
		arg.ConfirmationStatus,
		arg.FromAddress,
	)
	var i Transaction
	err := row.Scan(
		&i.Signature,
		&i.WalletAddress,
		&i.Slot,
		&i.BlockTime,
		&i.Amount,
		&i.TokenMint,
		&i.Memo,
		&i.ConfirmationStatus,
		&i.CreatedAt,
		&i.FromAddress,
	)
	return i, err
}

const deleteTransactionsOlderThan = `-- name: DeleteTransactionsOlderThan :exec
DELETE FROM transactions
WHERE block_time < $1
`

func (q *Queries) DeleteTransactionsOlderThan(ctx context.Context, blockTime pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteTransactionsOlderThan, blockTime)
	return err
}

const getLatestTransactionByWallet = `-- name: GetLatestTransactionByWallet :one
SELECT signature, wallet_address, slot, block_time, amount, token_mint, memo, confirmation_status, created_at, from_address FROM transactions
WHERE wallet_address = $1
ORDER BY block_time DESC
LIMIT 1
`

func (q *Queries) GetLatestTransactionByWallet(ctx context.Context, walletAddress string) (Transaction, error) {
	row := q.db.QueryRow(ctx, getLatestTransactionByWallet, walletAddress)
	var i Transaction
	err := row.Scan(
		&i.Signature,
		&i.WalletAddress,
		&i.Slot,
		&i.BlockTime,
		&i.Amount,
		&i.TokenMint,
		&i.Memo,
		&i.ConfirmationStatus,
		&i.CreatedAt,
		&i.FromAddress,
	)
	return i, err
}

const getTransaction = `-- name: GetTransaction :one
SELECT signature, wallet_address, slot, block_time, amount, token_mint, memo, confirmation_status, created_at, from_address FROM transactions
WHERE signature = $1
LIMIT 1
`

func (q *Queries) GetTransaction(ctx context.Context, signature string) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransaction, signature)
	var i Transaction
	err := row.Scan(
		&i.Signature,
		&i.WalletAddress,
		&i.Slot,
		&i.BlockTime,
		&i.Amount,
		&i.TokenMint,
		&i.Memo,
		&i.ConfirmationStatus,
		&i.CreatedAt,
		&i.FromAddress,
	)
	return i, err
}

const getTransactionSignaturesByWallet = `-- name: GetTransactionSignaturesByWallet :many
SELECT signature FROM transactions
WHERE wallet_address = $1
AND ($2::timestamptz IS NULL OR block_time > $2)
ORDER BY block_time DESC
LIMIT $3
`

type GetTransactionSignaturesByWalletParams struct {
	WalletAddress string             `json:"wallet_address"`
	Since         pgtype.Timestamptz `json:"since"`
	LimitCount    int32              `json:"limit_count"`
}

func (q *Queries) GetTransactionSignaturesByWallet(ctx context.Context, arg GetTransactionSignaturesByWalletParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getTransactionSignaturesByWallet, arg.WalletAddress, arg.Since, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var signature string
		if err := rows.Scan(&signature); err != nil {
			return nil, err
		}
		items = append(items, signature)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsSince = `-- name: GetTransactionsSince :many
SELECT signature, wallet_address, slot, block_time, amount, token_mint, memo, confirmation_status, created_at, from_address FROM transactions
WHERE wallet_address = $1
  AND block_time > $2
ORDER BY block_time ASC
`

type GetTransactionsSinceParams struct {
	WalletAddress string             `json:"wallet_address"`
	BlockTime     pgtype.Timestamptz `json:"block_time"`
}

func (q *Queries) GetTransactionsSince(ctx context.Context, arg GetTransactionsSinceParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsSince, arg.WalletAddress, arg.BlockTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.Signature,
			&i.WalletAddress,
			&i.Slot,
			&i.BlockTime,
			&i.Amount,
			&i.TokenMint,
			&i.Memo,
			&i.ConfirmationStatus,
			&i.CreatedAt,
			&i.FromAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByTimeRange = `-- name: ListTransactionsByTimeRange :many
SELECT signature, wallet_address, slot, block_time, amount, token_mint, memo, confirmation_status, created_at, from_address FROM transactions
WHERE block_time >= $1::timestamptz
  AND block_time <= $2::timestamptz
ORDER BY block_time ASC
`

type ListTransactionsByTimeRangeParams struct {
	StartTime pgtype.Timestamptz `json:"start_time"`
	EndTime   pgtype.Timestamptz `json:"end_time"`
}

func (q *Queries) ListTransactionsByTimeRange(ctx context.Context, arg ListTransactionsByTimeRangeParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactionsByTimeRange, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.Signature,
			&i.WalletAddress,
			&i.Slot,
			&i.BlockTime,
			&i.Amount,
			&i.TokenMint,
			&i.Memo,
			&i.ConfirmationStatus,
			&i.CreatedAt,
			&i.FromAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByWallet = `-- name: ListTransactionsByWallet :many
SELECT signature, wallet_address, slot, block_time, amount, token_mint, memo, confirmation_status, created_at, from_address FROM transactions
WHERE wallet_address = $1
  AND from_address IS NOT NULL
ORDER BY block_time DESC
LIMIT $2 OFFSET $3
`

type ListTransactionsByWalletParams struct {
	WalletAddress string `json:"wallet_address"`
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
}

func (q *Queries) ListTransactionsByWallet(ctx context.Context, arg ListTransactionsByWalletParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactionsByWallet, arg.WalletAddress, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.Signature,
			&i.WalletAddress,
			&i.Slot,
			&i.BlockTime,
			&i.Amount,
			&i.TokenMint,
			&i.Memo,
			&i.ConfirmationStatus,
			&i.CreatedAt,
			&i.FromAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByWalletAndTimeRange = `-- name: ListTransactionsByWalletAndTimeRange :many
SELECT signature, wallet_address, slot, block_time, amount, token_mint, memo, confirmation_status, created_at, from_address FROM transactions
WHERE wallet_address = $1
  AND block_time >= $2
  AND block_time <= $3
ORDER BY block_time DESC
`

type ListTransactionsByWalletAndTimeRangeParams struct {
	WalletAddress string             `json:"wallet_address"`
	BlockTime     pgtype.Timestamptz `json:"block_time"`
	BlockTime_2   pgtype.Timestamptz `json:"block_time_2"`
}

func (q *Queries) ListTransactionsByWalletAndTimeRange(ctx context.Context, arg ListTransactionsByWalletAndTimeRangeParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactionsByWalletAndTimeRange, arg.WalletAddress, arg.BlockTime, arg.BlockTime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.Signature,
			&i.WalletAddress,
			&i.Slot,
			&i.BlockTime,
			&i.Amount,
			&i.TokenMint,
			&i.Memo,
			&i.ConfirmationStatus,
			&i.CreatedAt,
			&i.FromAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
