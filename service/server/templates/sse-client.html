<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Forohtoo Transaction Stream</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="alternate icon" href="/favicon.ico" />
    <script src="https://unpkg.com/rxjs@7/dist/bundles/rxjs.umd.min.js"></script>
    <script src="https://unpkg.com/d3@7/dist/d3.min.js"></script>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background: #f5f5f5;
      }
      .header {
        background: white;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      .controls {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
      }
      input {
        flex: 1;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
      }
      button {
        padding: 10px 20px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
      }
      .btn-connect {
        background: #4caf50;
        color: white;
      }
      .btn-disconnect {
        background: #f44336;
        color: white;
      }
      .btn-clear {
        background: #2196f3;
        color: white;
      }
      .status {
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
        font-weight: 500;
      }
      .status.disconnected {
        background: #ffebee;
        color: #c62828;
      }
      .status.connected {
        background: #e8f5e9;
        color: #2e7d32;
      }
      .status.connecting {
        background: #fff3e0;
        color: #ef6c00;
      }
      .transactions {
        background: white;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      .chart {
        background: white;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        margin-top: 20px;
      }
      svg.timeline {
        width: 100%;
        height: 280px;
      }
      .brush .selection {
        fill: #4caf50;
        fill-opacity: 0.15;
        stroke: #4caf50;
        stroke-width: 2px;
        stroke-dasharray: 4 2;
      }
      .brush .handle {
        fill: #4caf50;
        cursor: ew-resize;
        rx: 3;
      }
      .transaction {
        border-bottom: 1px solid #eee;
        padding: 15px 0;
        animation: fadeIn 0.3s;
        transition: background-color 0.3s, transform 0.3s;
      }
      .transaction:last-child {
        border-bottom: none;
      }
      .transaction.highlighted {
        background-color: #e8f5e9;
        transform: scale(1.01);
        border-radius: 4px;
        padding: 15px 10px;
      }
      .transaction-header {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
      }
      .signature {
        font-family: "Courier New", monospace;
        font-size: 12px;
        color: #666;
        word-break: break-all;
      }
      .amount {
        font-size: 18px;
        font-weight: 600;
        color: #4caf50;
      }
      .meta {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 10px;
        margin-top: 10px;
        font-size: 13px;
        color: #666;
      }
      .meta-item {
        display: flex;
        flex-direction: column;
      }
      .meta-label {
        font-weight: 500;
        color: #999;
        font-size: 11px;
        text-transform: uppercase;
        margin-bottom: 2px;
      }
      .empty {
        text-align: center;
        color: #999;
        padding: 40px;
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(-10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      .count {
        color: #666;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1>ðŸš€ Forohtoo Transaction Stream</h1>
      <p>
        Real-time Solana wallet transaction streaming via Server-Sent Events
      </p>
    </div>

    <div class="controls">
      <input
        type="text"
        id="walletAddress"
        placeholder="Enter wallet address (leave empty for all wallets)"
        value=""
      />
      <button class="btn-connect" onclick="connect()">Connect</button>
      <button class="btn-disconnect" onclick="disconnect()">Disconnect</button>
      <button class="btn-clear" onclick="clearTransactions()">Clear</button>
    </div>

    <div class="status disconnected" id="status">Disconnected</div>

    <div class="chart">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
        <h2 style="margin: 0">USDC Timeline</h2>
        <div style="display: flex; gap: 10px; align-items: center;">
          <button class="btn-clear" onclick="resetTimeRange()" style="padding: 6px 12px; font-size: 12px;">Reset Zoom</button>
          <span id="timeRangeLabel" style="font-size: 12px; color: #666;"></span>
        </div>
      </div>
      <div style="font-size: 11px; color: #999; margin-bottom: 8px;">
        ðŸ’¡ Drag to select a time range, click outside to reset
      </div>
      <svg id="timeline" class="timeline"></svg>
    </div>

    <div class="transactions">
      <div
        style="
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 15px;
        "
      >
        <h2 style="margin: 0">Transactions</h2>
        <span class="count" id="count">0 transactions</span>
      </div>
      <div id="transactionList">
        <div class="empty">
          Enter a wallet address and click Connect to start streaming
          transactions.
        </div>
      </div>
    </div>

    <script id="template-data" type="application/json">
      {
        "usdcMainnetMintAddress": {{if .USDCMainnetMintAddress}}"{{.USDCMainnetMintAddress}}"{{else}}""{{end}},
        "usdcDevnetMintAddress": {{if .USDCDevnetMintAddress}}"{{.USDCDevnetMintAddress}}"{{else}}""{{end}}
      }
    </script>

    <script>
      // Load template data
      const templateData = JSON.parse(
        document.getElementById("template-data").textContent
      );
      const USDC_MAINNET_MINT_ADDRESS = templateData.usdcMainnetMintAddress;
      const USDC_DEVNET_MINT_ADDRESS = templateData.usdcDevnetMintAddress;

      // Helper to check if a token is USDC (mainnet or devnet)
      function isUSDC(tokenType) {
        return tokenType === USDC_MAINNET_MINT_ADDRESS || tokenType === USDC_DEVNET_MINT_ADDRESS;
      }

      let eventSource = null;
      let transactionCount = 0;
      let subscriptions = [];
      const knownSignatures = new Set();
      let timelineData = []; // Array of TransactionEvent
      const SERVER_URL = window.location.origin;

      // Time range state
      let currentTimeRange = null; // null means show all data
      let brush = null; // D3 brush instance

      function updateStatus(status, message) {
        const statusEl = document.getElementById("status");
        statusEl.className = `status ${status}`;
        statusEl.textContent = message;
      }

      function updateCount() {
        document.getElementById(
          "count"
        ).textContent = `${transactionCount} transaction${
          transactionCount !== 1 ? "s" : ""
        }`;
      }

      function formatAmount(amount, tokenType) {
        // Check for USDC first (by mint address - mainnet or devnet)
        if (tokenType && isUSDC(tokenType)) {
          // USDC (6 decimals)
          return `${(amount / 1e6).toFixed(2)} USDC`;
        }

        // Check if it's native SOL (empty or null tokenType)
        if (!tokenType || tokenType === "") {
          // Native SOL (9 decimals)
          return `${(amount / 1e9).toFixed(4)} SOL`;
        }

        // Unknown SPL token - use 6 decimals as default for most SPL tokens
        return `${(amount / 1e6).toFixed(6)} SPL`;
      }

      function formatDate(dateString) {
        return new Date(dateString).toLocaleString();
      }

      // D3 timeline rendering
      const margin = { top: 10, right: 16, bottom: 28, left: 48 };
      function renderTimeline(data) {
        const svg = d3.select("#timeline");
        const width = svg.node().clientWidth;
        const height = svg.node().clientHeight;
        const innerWidth = Math.max(0, width - margin.left - margin.right);
        const innerHeight = Math.max(0, height - margin.top - margin.bottom);

        // Ensure a single root g
        let gRoot = svg.select("g.root");
        if (gRoot.empty()) {
          svg.selectAll("*").remove();
          gRoot = svg
            .append("g")
            .attr("class", "root")
            .attr("transform", `translate(${margin.left},${margin.top})`);
          gRoot.append("g").attr("class", "brush-layer");
          gRoot
            .append("g")
            .attr("class", "x-axis")
            .attr("transform", `translate(0,${innerHeight})`);
          gRoot.append("g").attr("class", "y-axis");
          gRoot.append("g").attr("class", "points");
        }

        if (!data || data.length === 0) {
          // Clear points but keep axes
          gRoot.select("g.points").selectAll("circle").data([]).join("circle");
          gRoot
            .select("g.x-axis")
            .call(d3.axisBottom(d3.scaleTime().range([0, innerWidth])));
          gRoot
            .select("g.y-axis")
            .call(
              d3
                .axisLeft(
                  d3.scaleLinear().domain([0, 1]).range([innerHeight, 0])
                )
                .ticks(0)
            );
          return;
        }

        // Filter to only USDC transactions (mainnet or devnet)
        const usdcData = data.filter((d) => d.token_type && isUSDC(d.token_type));

        // Determine time range: use currentTimeRange if set, otherwise use all data
        let timeExtent;
        if (currentTimeRange) {
          timeExtent = currentTimeRange;
        } else if (usdcData.length > 0) {
          // Use data extent
          timeExtent = d3.extent(usdcData, (d) => new Date(d.block_time || d.published_at));
        } else {
          // Fallback to last 24 hours if no data
          const now = new Date();
          timeExtent = [new Date(now.getTime() - 24 * 60 * 60 * 1000), now];
        }

        const x = d3
          .scaleTime()
          .domain(timeExtent)
          .range([0, innerWidth]);

        // Y encodes USDC amount (convert from micro-USDC to USDC)
        const usdcAmounts = usdcData.map((d) => (d.amount || 0) / 1e6);
        const yMax = Math.max(1, d3.max(usdcAmounts) || 1);
        const y = d3
          .scaleLinear()
          .domain([0, yMax])
          .range([innerHeight - 4, 12])
          .nice();

        // Axes with time formatting
        const xAxis = d3
          .axisBottom(x)
          .ticks(8)
          .tickFormat(d3.timeFormat("%b %d %H:%M"));
        gRoot.select("g.x-axis").call(xAxis);

        const yAxis = d3
          .axisLeft(y)
          .ticks(5)
          .tickFormat((d) => `$${d.toFixed(2)}`);
        gRoot.select("g.y-axis").call(yAxis);

        // Color by confirmation status
        function color(d) {
          const s = (d.confirmation_status || "").toLowerCase();
          if (s === "failed") return "#f44336";
          if (s === "confirmed") return "#4caf50";
          return "#9e9e9e";
        }

        // Data join (only USDC transactions)
        const points = gRoot
          .select("g.points")
          .selectAll("circle")
          .data(usdcData, (d) => d.signature);

        const joined = points.join(
          (enter) => {
            const circles = enter
              .append("circle")
              .attr("r", 6)
              .attr("cx", (d) => x(new Date(d.block_time || d.published_at)))
              .attr("cy", (d) => y((d.amount || 0) / 1e6))
              .attr("fill", color)
              .attr("opacity", 0.8)
              .attr("stroke", "#fff")
              .attr("stroke-width", 1.5)
              .style("cursor", "pointer")
              .on("click", function(event, d) {
                event.stopPropagation(); // Prevent brush from triggering
                scrollToTransaction(d.signature);
              })
              .on("mouseenter", function() {
                d3.select(this).attr("r", 8).attr("opacity", 1);
              })
              .on("mouseleave", function() {
                d3.select(this).attr("r", 6).attr("opacity", 0.8);
              });

            circles
              .append("title")
              .text(
                (d) =>
                  `${d.signature}\n${formatAmount(
                    d.amount || 0,
                    d.token_type
                  )}\n${formatDate(d.block_time || d.published_at)}\n\nClick to scroll to transaction`
              );

            return circles;
          },
          (update) => {
            update
              .attr("cx", (d) => x(new Date(d.block_time || d.published_at)))
              .attr("cy", (d) => y((d.amount || 0) / 1e6))
              .attr("fill", color);

            update
              .select("title")
              .text(
                (d) =>
                  `${d.signature}\n${formatAmount(
                    d.amount || 0,
                    d.token_type
                  )}\n${formatDate(d.block_time || d.published_at)}`
              );

            return update;
          },
          (exit) => exit.remove()
        );

        // Add brush for time range selection (integrated into the main timeline)
        if (usdcData.length > 0) {
          // Get full time extent from all data
          const fullTimeExtent = d3.extent(usdcData, (d) => new Date(d.block_time || d.published_at));
          const fullXScale = d3.scaleTime().domain(fullTimeExtent).range([0, innerWidth]);

          // Create or update brush
          if (!brush) {
            brush = d3.brushX()
              .extent([[0, 0], [innerWidth, innerHeight]])
              .on("end", brushed);
          }

          const brushLayer = gRoot.select("g.brush-layer");
          brushLayer.selectAll("*").remove();
          brushLayer.call(brush);

          function brushed(event) {
            const selection = event.selection;
            if (!event.sourceEvent) return; // Ignore programmatic brush updates

            if (selection) {
              // User selected a range
              currentTimeRange = selection.map(fullXScale.invert);
              // Clear the brush selection visually after capturing the range
              brushLayer.call(brush.move, null);
              renderTimeline(timelineData);
            } else {
              // User clicked outside to deselect
              currentTimeRange = null;
              renderTimeline(timelineData);
            }
          }
        }

        updateTimeRangeLabel();
      }

      // Update the time range label
      function updateTimeRangeLabel() {
        const label = document.getElementById("timeRangeLabel");
        if (currentTimeRange) {
          const fmt = d3.timeFormat("%b %d, %H:%M");
          label.textContent = `Showing: ${fmt(currentTimeRange[0])} - ${fmt(currentTimeRange[1])}`;
        } else {
          label.textContent = "Showing: All data";
        }
      }

      // Reset time range to show all data
      function resetTimeRange() {
        currentTimeRange = null;
        if (brush) {
          d3.select("#timeline .brush-layer").call(brush.move, null);
        }
        renderTimeline(timelineData);
      }

      // Scroll to and highlight a transaction in the list
      function scrollToTransaction(signature) {
        // Remove any existing highlights
        document.querySelectorAll(".transaction.highlighted").forEach((el) => {
          el.classList.remove("highlighted");
        });

        // Find the transaction element
        const txnEl = document.querySelector(
          `.transaction[data-signature="${signature}"]`
        );
        if (txnEl) {
          // Scroll to it smoothly
          txnEl.scrollIntoView({
            behavior: "smooth",
            block: "center",
          });

          // Highlight it
          txnEl.classList.add("highlighted");

          // Remove highlight after 3 seconds
          setTimeout(() => {
            txnEl.classList.remove("highlighted");
          }, 3000);
        }
      }

      function addTransaction(txn) {
        const listEl = document.getElementById("transactionList");

        // Remove empty message if exists
        if (listEl.querySelector(".empty")) {
          listEl.innerHTML = "";
        }

        const txnEl = document.createElement("div");
        txnEl.className = "transaction";
        txnEl.setAttribute("data-signature", txn.signature);

        const metaItems = [];
        metaItems.push(`
                <div class="meta-item">
                    <div class="meta-label">Wallet</div>
                    <div class="signature">${txn.wallet_address}</div>
                </div>
            `);
        metaItems.push(`
                <div class="meta-item">
                    <div class="meta-label">Network</div>
                    <div style="text-transform: uppercase; font-weight: 600; color: ${txn.network === 'mainnet' ? '#4caf50' : '#2196f3'}">${txn.network || 'mainnet'}</div>
                </div>
            `);
        metaItems.push(`
                <div class="meta-item">
                    <div class="meta-label">Slot</div>
                    <div>${txn.slot.toLocaleString()}</div>
                </div>
            `);
        metaItems.push(`
                <div class="meta-item">
                    <div class="meta-label">Status</div>
                    <div>${txn.confirmation_status}</div>
                </div>
            `);
        metaItems.push(`
                <div class="meta-item">
                    <div class="meta-label">Block Time</div>
                    <div>${formatDate(txn.block_time)}</div>
                </div>
            `);

        if (txn.token_type) {
          metaItems.push(`
                    <div class="meta-item">
                        <div class="meta-label">Token</div>
                        <div class="signature">${txn.token_type}</div>
                    </div>
                `);
        }

        if (txn.memo) {
          metaItems.push(`
                    <div class="meta-item">
                        <div class="meta-label">Memo</div>
                        <div>${txn.memo}</div>
                    </div>
                `);
        }

        txnEl.innerHTML = `
                <div class="transaction-header">
                    <div class="amount">${formatAmount(
                      txn.amount,
                      txn.token_type
                    )}</div>
                    <div style="font-size: 12px; color: #999;">${formatDate(
                      txn.published_at
                    )}</div>
                </div>
                <div class="signature">Signature: ${txn.signature}</div>
                <div class="meta">
                    ${metaItems.join("")}
                </div>
            `;

        // Add to top of list
        listEl.insertBefore(txnEl, listEl.firstChild);
        transactionCount++;
        updateCount();
      }

      // RxJS helpers
      const { Observable, merge, fromEventPattern } = rxjs;
      const { map, filter, tap, mergeMap, bufferTime } = rxjs.operators;

      function fromSSE(es, eventName) {
        return new Observable((subscriber) => {
          const handler = (e) => {
            try {
              subscriber.next(JSON.parse(e.data));
            } catch (err) {
              console.error("Failed to parse SSE data", err);
            }
          };
          es.addEventListener(eventName, handler);
          return () => es.removeEventListener(eventName, handler);
        });
      }

      function setupStreams(url) {
        const es = new EventSource(url);
        eventSource = es;

        es.onopen = (e) => {
          console.log("EventSource connection opened:", {
            readyState: es.readyState,
            url: es.url,
          });
        };

        const connected$ = fromSSE(es, "connected");
        const chunks$ = fromSSE(es, "transactions_chunk");
        const live$ = fromSSE(es, "transaction");

        // Handle connected event (UI only)
        subscriptions.push(
          connected$.subscribe((data) => {
            updateStatus("connected", `Connected to ${data.wallet}`);
          })
        );

        // Historical chunks: apply in batches, single render per chunk
        subscriptions.push(
          chunks$.subscribe((payload) => {
            const events = Array.isArray(payload.events) ? payload.events : [];
            let added = 0;
            for (const ev of events) {
              if (knownSignatures.has(ev.signature)) continue;
              knownSignatures.add(ev.signature);
              timelineData.push(ev);
              addTransaction(ev);
              added++;
            }
            if (added > 0) {
              // Sort by time once per chunk
              timelineData.sort(
                (a, b) =>
                  new Date(a.block_time || a.published_at) -
                  new Date(b.block_time || b.published_at)
              );
              renderTimeline(timelineData);
            }
          })
        );

        // Live events: incremental updates
        subscriptions.push(
          live$.subscribe((ev) => {
            if (knownSignatures.has(ev.signature)) return;
            knownSignatures.add(ev.signature);
            timelineData.push(ev);
            addTransaction(ev);
            // Keep sorted; since live usually appends newer, do a cheap check
            const n = timelineData.length;
            if (n >= 2) {
              const prev = timelineData[n - 2];
              const tPrev = new Date(
                prev.block_time || prev.published_at
              ).getTime();
              const tCur = new Date(ev.block_time || ev.published_at).getTime();
              if (tCur < tPrev) {
                timelineData.sort(
                  (a, b) =>
                    new Date(a.block_time || a.published_at) -
                    new Date(b.block_time || b.published_at)
                );
              }
            }
            renderTimeline(timelineData);
          })
        );

        // Error handling
        es.onerror = (e) => {
          console.error("SSE connection error:", {
            event: e,
            eventType: e.type,
            readyState: es ? es.readyState : "null",
            readyStateText: es
              ? es.readyState === 0
                ? "CONNECTING"
                : es.readyState === 1
                ? "OPEN"
                : es.readyState === 2
                ? "CLOSED"
                : "UNKNOWN"
              : "null",
            url: es ? es.url : "null",
            timestamp: new Date().toISOString(),
          });

          if (es && es.readyState === EventSource.CLOSED) {
            console.warn("EventSource closed permanently");
            updateStatus("disconnected", "Connection closed by server");
            disconnect();
          } else if (es && es.readyState === EventSource.CONNECTING) {
            console.warn("EventSource reconnecting...");
            updateStatus("connecting", "Reconnecting...");
          } else {
            console.error("EventSource error in unknown state");
            updateStatus("disconnected", "Connection error (see console)");
            disconnect();
          }
        };
      }

      function connect() {
        if (eventSource) {
          disconnect();
        }

        const walletAddress = document
          .getElementById("walletAddress")
          .value.trim();
        let url;

        if (walletAddress) {
          url = `${SERVER_URL}/api/v1/stream/transactions/${walletAddress}`;
          updateStatus("connecting", `Connecting to ${walletAddress}...`);
        } else {
          url = `${SERVER_URL}/api/v1/stream/transactions`;
          updateStatus("connecting", "Connecting to all wallets...");
        }

        // Reset state for a fresh view
        knownSignatures.clear();
        timelineData = [];
        document.getElementById("transactionList").innerHTML =
          '<div class="empty">Loading historical transactionsâ€¦</div>';
        transactionCount = 0;
        updateCount();
        renderTimeline(timelineData);

        setupStreams(url);
      }

      function disconnect() {
        if (eventSource) {
          eventSource.close();
          eventSource = null;
          updateStatus("disconnected", "Disconnected");
        }
        // Unsubscribe all
        for (const sub of subscriptions) {
          try {
            sub.unsubscribe && sub.unsubscribe();
          } catch (_) {}
        }
        subscriptions = [];
      }

      function clearTransactions() {
        document.getElementById("transactionList").innerHTML =
          '<div class="empty">No transactions yet</div>';
        transactionCount = 0;
        updateCount();
        knownSignatures.clear();
        timelineData = [];
        renderTimeline(timelineData);
      }

      // Connect on Enter key
      document
        .getElementById("walletAddress")
        .addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
            connect();
          }
        });

      // Cleanup on page unload
      window.addEventListener("beforeunload", () => {
        disconnect();
      });
    </script>
  </body>
</html>
